<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Concept Connector</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: sans-serif;
            padding: 20px;
            margin: 0;
        }

        h2 {
            margin-bottom: 0.5em;
        }

        #interactive-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
            position: relative;
        }

        #workspace {
            display: flex;
            justify-content: space-between;
            padding: 0 60px;
            position: relative;
            max-width: 1000px;
            width: 600px;

            /* Added height property */
            min-height: 300px;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 12px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        #left-column,
        #right-column {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 12px;
            padding: 10px;
            position: relative;
            z-index: 1;
        }

        .box {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 120px;
            padding: 10px 14px;
            min-height: 50px;
            background: #f1c40f;
            border: 2px solid #e67e22;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            user-select: none;
            cursor: pointer;
            white-space: nowrap;
        }

        .box:focus {
            outline: 3px solid #3498db;
        }

        .box.selected {
            outline: 3px dashed #27ae60;
        }

        #connector-svg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 0;
        }

        .line {
            stroke: black;
            stroke-width: 2;
            cursor: pointer;
            pointer-events: auto;
            transition: stroke 0.2s ease, stroke-width 0.2s ease;
        }

        .line.faded {
            stroke: #ccc;
            stroke-width: 1;
        }

        .line.highlighted {
            stroke: #e74c3c;
            stroke-width: 3;
        }

        .line.correct {
            stroke: #18e4d1;
            stroke-width: 3;
        }

        .line.incorrect {
            stroke: #ccc;
            stroke-width: 1;
        }

        #connection-model {
            max-width: 800px;
            margin: 20px auto;
            padding: 10px;
            background: #f9f9f9;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 14px;
        }

        .conn-entry {
            margin: 4px 0;
            font-family: monospace;
        }

        button {
            display: block;
            margin: 1rem auto 0;
            font-size: 1rem;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background: #3498db;
            color: white;
            cursor: pointer;
            transition: background 0.2s ease-in-out;
        }

        button:hover {
            background: #2980b9;
        }

        #aria-live {
            position: absolute;
            left: -9999px;
            top: auto;
            width: 1px;
            height: 1px;
            overflow: hidden;
        }
    </style>
    <script>
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
            svg: { fontCache: 'global' }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>

<body>

    <h2>Connect the Concepts</h2>
    <p>Match each concept on the left with its correct description on the right. Use your mouse or keyboard (Tab +
        Enter).</p>

    <div id="interactive-container">
        <div id="workspace">
            <div id="left-column"></div>
            <svg id="connector-svg"></svg>
            <div id="right-column"></div>
        </div>
    </div>

    <div id="connection-model">
        <div id="conn-list"></div>
        <button onclick="gradeConnections()">Grade</button>
        <button onclick="resetConnections()">Reset</button>
    </div>

    <div id="aria-live" aria-live="polite" aria-atomic="true"></div>

    <!-- Your app logic -->
    <script>
        const boxData = {
            left: [
                { id: "a", label: "<i>Gravity</i>" },
                { id: "b", label: "The Moon" },
                { id: "c", label: "A Black Hole" }
            ],
            right: [
                { id: "d", label: "A force that pulls" },
                { id: "e", label: "Orbits Earth" },
                { id: "f", label: "Nothing escapes &nbsp; \\(e = m c^2\\)" }
            ],
            correctAnswers: [
                ["a", "d"],
                ["b", "e"],
                ["c", "f"]
            ]
        };

        const leftColumn = document.getElementById('left-column');
        const rightColumn = document.getElementById('right-column');
        const svg = document.getElementById('connector-svg');
        const connList = document.getElementById('conn-list');
        const ariaLive = document.getElementById('aria-live');
        const connections = [];
        const allBoxes = [];

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function createBox(id, label, role) {
            const div = document.createElement('div');
            div.className = 'box';
            div.dataset.id = id;
            div.dataset.role = role;
            div.innerHTML = label;
            div.tabIndex = 0;
            div.setAttribute('role', 'button');
            div.setAttribute('aria-label', `${role === "drag" ? "Draggable" : "Droppable"}: ${label}`);
            return div;
        }

        function getLabelById(id) {
            const item = [...boxData.left, ...boxData.right].find(box => box.id === id);
            return item ? item.label : id;
        }

        function getCenter(el) {
            const rect = el.getBoundingClientRect();
            return {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
        }

        function createLineElement(x1, y1, x2, y2) {
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", x1);
            line.setAttribute("y1", y1);
            line.setAttribute("x2", x2);
            line.setAttribute("y2", y2);
            line.setAttribute("class", "line");

            line.addEventListener("click", () => {
                svg.removeChild(line);
                const index = connections.findIndex(conn =>
                    (conn.fromBox === line.fromBox && conn.toBox === line.toBox) ||
                    (conn.fromBox === line.toBox && conn.toBox === line.fromBox)
                );
                if (index !== -1) connections.splice(index, 1);
                updateConnectionModel();
            });

            return line;
        }

        function isConnected(a, b) {
            return connections.some(conn =>
                (conn.fromBox === a && conn.toBox === b) ||
                (conn.fromBox === b && conn.toBox === a)
            );
        }

        function createPermanentLine(fromBox, toBox) {
            const fromRole = fromBox.dataset.role;
            const toRole = toBox.dataset.role;

            if (fromRole === toRole) {
                alert("You can only connect a draggable to a droppable.");
                return;
            }

            if (isConnected(fromBox, toBox)) return;

            const from = getCenter(fromBox);
            const to = getCenter(toBox);
            const line = createLineElement(from.x, from.y, to.x, to.y);

            line.fromBox = fromBox;
            line.toBox = toBox;

            svg.appendChild(line);
            connections.push({ fromBox, toBox, line });
            updateConnectionModel();

            if (ariaLive) {
                ariaLive.textContent = `Connected ${fromBox.textContent} to ${toBox.textContent}`;
            }
        }

        function updateConnectionModel() {
            connList.innerHTML = "<strong>Connections:</strong><br>";
            connections.forEach(conn => {
                const fromLabel = conn.fromBox.textContent;
                const toLabel = conn.toBox.textContent;
                const line = document.createElement('div');
                line.className = 'conn-entry';
                line.textContent = `${fromLabel} → ${toLabel}`;
                connList.appendChild(line);
            });
        }

        function gradeConnections() {
            const actual = connections.map(conn => [
                conn.fromBox.dataset.id,
                conn.toBox.dataset.id
            ]);

            const results = [];

            boxData.correctAnswers.forEach(expected => {
                const found = actual.some(actualConn =>
                    actualConn[0] === expected[0] && actualConn[1] === expected[1]
                );
                results.push({ expected, correct: found });
            });

            const extraConnections = actual.filter(actualConn =>
                !boxData.correctAnswers.some(expected =>
                    expected[0] === actualConn[0] && expected[1] === actualConn[1]
                )
            );

            connList.innerHTML = "<strong>Grading:</strong><br>";



            const correctAnswers = boxData.correctAnswers;
            const totalExpected = correctAnswers.length;


            // Which correct answers were matched
            const correctMatches = correctAnswers.filter(expected =>
                actual.some(given =>
                    given[0] === expected[0] && given[1] === expected[1]
                )
            );

            // Connections that were NOT in the answer key
            const incorrectConnections = actual.filter(given =>
                !correctAnswers.some(expected =>
                    expected[0] === given[0] && expected[1] === given[1]
                )
            );

            const correctCount = correctMatches.length;
            const incorrectCount = incorrectConnections.length;
            const missingCount = totalExpected - correctCount;

            const denominator = correctCount + incorrectCount + missingCount;

            let scorePercent = denominator === 0 ? 0 : Math.round((correctCount / denominator) * 100); const scoreLine = document.createElement('div');

            // ✅ Style each line visually
            connections.forEach(conn => {
                const idPair = [conn.fromBox.dataset.id, conn.toBox.dataset.id];
                const isCorrect = correctAnswers.some(expected =>
                    expected[0] === idPair[0] && expected[1] === idPair[1]
                );

                conn.line.classList.remove("correct", "incorrect");
                conn.line.classList.add(isCorrect ? "correct" : "incorrect");
            });

            scoreLine.innerHTML = `<br><strong>Score: ${scorePercent}%</strong>`;
            connList.appendChild(scoreLine);
        }

        function resetConnections() {
            // Remove all SVG lines
            connections.forEach(conn => {
                if (conn.line && conn.line.parentNode === svg) {
                    svg.removeChild(conn.line);
                }
            });

            // Clear internal array
            connections.length = 0;

            // Update connection display
            updateConnectionModel();

            // Optional: Clear live feedback
            if (ariaLive) {
                ariaLive.textContent = "All connections have been cleared.";
            }
        }
        // Setup boxes
        shuffle(boxData.left);
        shuffle(boxData.right);
        boxData.left.forEach(({ id, label }) => {
            const box = createBox(id, label, "drag");
            leftColumn.appendChild(box);
            allBoxes.push(box);
        });

        boxData.right.forEach(({ id, label }) => {
            const box = createBox(id, label, "drop");
            rightColumn.appendChild(box);
            allBoxes.push(box);
        });


        // ✅ Tell MathJax to render everything
        if (window.MathJax && MathJax.typesetPromise) {
            MathJax.typesetPromise();
        }
        // Keyboard selection
        let selectedBox = null;
        let startBox = null;
        let tempLine = null;

        allBoxes.forEach(box => {
            box.addEventListener("mousedown", e => {
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    startBox = box;
                    const from = getCenter(startBox);
                    tempLine = createLineElement(from.x, from.y, from.x, from.y);
                    tempLine.setAttribute("stroke", "gray");
                    tempLine.setAttribute("stroke-dasharray", "4");
                    svg.appendChild(tempLine);

                    document.addEventListener("mousemove", updateTempLine);
                    document.addEventListener("mouseup", finishConnection);
                }
            });

            box.addEventListener("keydown", (e) => {
                if (e.key === "Enter") {
                    e.preventDefault();
                    if (!selectedBox) {
                        selectedBox = box;
                        box.classList.add("selected");
                    } else {
                        if (box !== selectedBox) {
                            createPermanentLine(selectedBox, box);
                        }
                        selectedBox.classList.remove("selected");
                        selectedBox = null;

                        const currentIndex = allBoxes.indexOf(box);
                        const next = allBoxes[currentIndex + 1];
                        if (next) next.focus();
                        else allBoxes[0].focus();
                    }
                }
            });
            box.addEventListener("mouseenter", () => {
                connections.forEach(conn => {
                    conn.line.classList.remove("incorrect");
                    conn.line.classList.remove("correct");
                    if (conn.fromBox === box || conn.toBox === box) {
                        conn.line.classList.add("highlighted");
                        conn.line.classList.remove("faded");
                    } else {
                        conn.line.classList.add("faded");
                        conn.line.classList.remove("highlighted");
                    }
                });
            });

            box.addEventListener("mouseleave", () => {
                connections.forEach(conn => {
                    conn.line.classList.remove("highlighted", "faded");
                });
            });
        });

        function updateTempLine(e) {
            if (!startBox || !tempLine) return;
            const from = getCenter(startBox);
            tempLine.setAttribute("x1", from.x);
            tempLine.setAttribute("y1", from.y);
            tempLine.setAttribute("x2", e.clientX);
            tempLine.setAttribute("y2", e.clientY);
        }

        function finishConnection(e) {
            if (tempLine) {
                svg.removeChild(tempLine);
                tempLine = null;
            }

            const endBox = allBoxes.find(box =>
                box.contains(e.target) && box !== startBox
            );

            if (startBox && endBox) {
                createPermanentLine(startBox, endBox);
            }

            startBox = null;
            document.removeEventListener("mousemove", updateTempLine);
            document.removeEventListener("mouseup", finishConnection);
        }

        window.addEventListener("resize", () => {
            connections.forEach(conn => {
                const from = getCenter(conn.fromBox);
                const to = getCenter(conn.toBox);
                conn.line.setAttribute("x1", from.x);
                conn.line.setAttribute("y1", from.y);
                conn.line.setAttribute("x2", to.x);
                conn.line.setAttribute("y2", to.y);
            });
        });
    </script>


</body>

</html>